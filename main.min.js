function parseString(t){const e=[];function n(){const n=parseInt(t.split("/",1)[0]);if(Number.isNaN(n))return;const r=t.substring(n.toString().length+1,n.toString().length+1+n),s=(t=t.substring(n.toString().length+1+n)).split(":")[0].indexOf(",")+1,o=s?t.split(",",1)[0].split("."):t.split(":",1)[0].split(".");return e.push([r,o]),t=t.substring(o.join(".").length+1),s}let r;for(;(r=n())&&r;);return[t,e]}function getCompressedValue(t){return getOccString(t,t[0])===t.length?t.length+"/"+t[0]:"/"+t}function getOcc(t,e){return t.filter(t=>t===e).length}function getOccString(t,e){return t.split(e).length-1}function splitAtN(t,e){return e.match(new RegExp(`.{${t}}`,"g"))}function toFormatted(t,e,n){const r=getOccString(e,t),s=[];t.length;for(let n=0;n<r;n++)s.push(e.indexOf(t)),e=e.replace(t,"");const o=getCompressedValue(t);if(n){let t="";return n.forEach(e=>{t+=`,${e[0].length}/${e[0]+e[1].join(".")}`}),`${o.length}/${o}${s.join(".")}${t}:${e}`}return`${o.length}/${o}${s.join(".")}:${e}`}function sortFormatted(t){let e,n;return t.forEach(t=>{(t.length<e||!e)&&(e=t.length,n=t)}),n}function recompress(t,e,n,r,s){t.length;let o;e&&(o=parseString(t),t=o[0],o=o[1]);const i=function(){let e,o=2;const i=[];for(let l=0,g=function(t){return"full"===n.searchLength?Math.floor(t.length/2):Math.min(n.searchLength,Math.floor(t.length/2))}(t);l<g;l++){for(let e=0;e<o;e++){const n=splitAtN(o,t.substring(e));n&&i.push(n)}const c=Math.floor(l/g*100);c!==e&&(n.progressUpdate("searching",c,r,s),e=c),o++}return n.progressUpdate("searching",100,r,s),i}(),l=[];let g;for(let e=0,c=i.length;e<c;e++){i[e].forEach(e=>{l.push(toFormatted(e,t,o))});const p=Math.floor(e/c*100);p!==g&&(n.progressUpdate("formatting",p,r,s),g=p)}return n.progressUpdate("formatting",100,r,s),sortFormatted(l)}Object.defineProperty(window,"CL",{value:{},writable:!1});const defOptions={searchLength:"full",progressUpdate:()=>{}};function parseName(t){return t.indexOf("/")?t.split("/")[1].repeat(parseInt(t.split("/")[0])):t.substring(1)}function splice(t,e,n){return t.slice(0,e)+n+t.slice(e)}CL.compress=async function(t,e){if("string"!=typeof t)throw new TypeError("Invalid arguments passed");if(t.length<3)throw new RangeError("String is too small");if(e)for(const t in defOptions)e.hasOwnProperty(t)||(e[t]=defOptions[t]);else e=defOptions;const n=t;t.length;let r,s,o=!1,i=0;for(;(r=recompress(r||t,o,e,i++,n.length-(r?r.length:n.length)))&&!(n.length<=r.length||s&&s.length<=r.length);)s=r,o=!0;return{value:o?s:n,compressed:o,compressionPower:o?n.length-s.length:null}},CL.decompress=function(t){if("string"!=typeof t)throw new TypeError("Invalid arguments passed");const e=(t=parseString(t))[1];return t=t[0],e.forEach(e=>{const n=parseName(e[0]),r=e[1];r.reverse(),r.forEach(e=>{t=splice(t,e,n)})}),t};